CAN Translation Module
=========================

## Description

The CAN translation module code runs on an Arduino-compatible microcontroller
connected to one or more CAN buses. It receives either all CAN messages or a
filtered subset, performs any unit conversion or factoring required and outputs
a generic version to a USB interface.

For more documentation, see the [vehicle
interface](http://openxcplatform.com/vehicle-interface/index.html) section on
the [OpenXC website](http://openxcplatform.com).

Most OpenXC users do not need this, but [additional documentation][dev-docs] is
available for developers.

### Pre-built Binary

See the [firmware
section](http://openxcplatform.com/vehicle-interface/firmware.html) of the
[OpenXC website](http://openxcplatform.com).

## Input Specification

The code in this repository requires a list of CAN messages with details of the
signals of interest, and their corresponding generic versions. The input format
is a JSON object like this:

    {"0x102": {
        "speed": 500000,
        "messages": {
            "ECM_z_5D2": {
                "signals": {
                    "StrAnglAct": {
                        "human_signal_name": "Steering wheel angle",
                        "generic_name": "SteeringWheelAngle",
                        "bit_position": 52,
                        "bit_size": 12,
                        "factor": 0.15392,
                        "offset": 0,
                        "value_handler": "handleSteeringWheelAngle"},
                    "StrAnglSign": {
                        "human_signal_name": "Steering wheel angle sign",
                        "generic_name": "steering_angle_sign",
                        "value_handler": "ignoreHandler",
                        "bit_position": 52,
                        "bit_size": 12},
                    "EngSpd": {
                        "generic_name": "engine_speed",
                        "send_frequency": 15,
                        "bit_position": 12,
                        "bit_size": 8},
                    "GrshftPos": {
                        "human_signal_name": "Gearshift Position",
                        "generic_name": "GearshiftPosition",
                        "bit_position": 41,
                        "bit_size": 0,
                        "states": {
                            "FIRST": [1],
                            "SECOND": [2],
                            "THIRD": [3],
                            "FOURTH": [4],
                            "REVERSE": [5],
                            "NEUTRAL": [6]}
                        },
                    "StrAnglErr": {
                        "value_handler": "ignoreHandler"
                    }
                },
                "handler": "handleSteeringWheelMessage"
            },
            "BrkSt": {
                "signals": {
                    "BrakePedalPosition": {
                        "generic_name": "brake_pedal_status",
                        "send_same": false,
                        "value_handler": "booleanHandler",
                        "bit_position": 0,
                        "bit_size": 0
                    }
                }
            },
            "Cluster": {
                "signals": {
                    "TurnSignalLeft": {
                        "generic_name": "turn_signal_left",
                        "value_handler": "booleanHandler",
                        "bit_position": 0,
                        "bit_size": 0,
                        "writable": true,
                        "write_handler": "booleanWriter"
                    },
                    "TurnSignalRight": {
                        "generic_name": "turn_signal_right",
                        "value_handler": "booleanHandler",
                        "bit_position": 1,
                        "bit_size": 0,
                        "writable": true,
                        "write_handler": "booleanWriter"
                    }
                }
            }
        },
        "commands": {
            "turn_signal_status": {
                "handler": "handleTurnSignalCommand"
            }
        }
    }}

This is a list of CAN buses (the `0x102` is the unique bus address), messages in
each bus and a list of signals within each message. The `speed` attribute on the
bus is the CAN bus speed in Kbps. The attributes of a signal are:

`name` - The official name of the signal - often a terse spelling.
    Optional - just used to be able to reference back to original documentation
    from this list.

`human_signal_name` - A more friendly, human readable version of the signal's
    name. Optional - just used in comments so the generated source is clearer.

`generic_name` - The name of the associated generic signal name (from the OpenXC
    specification) that this should be translated to. Optional - if not
    specified, the signal is read and stored in memory, but not sent to the
    output bus. This is handy for combining the value of multiple signals into a
    composite measurement such as steering wheel angle with its sign.

`bit_position` - The staring bit position of this signal within the message.

`bit_size` - The width in bits of the signal.

`factor` - The signal value is multiplied by this if set. Optional.

`offset` - This is added to the signal value if set. Optional.

`value_handler` - The return type and name of a function that will be compiled
    with the sketch and should be applied to the signal's value after the normal
    translation. Optional - see the "Custom Handlers" section for more.

`handler` - The name of a function that will be compiled with the sketch
    and should be applied to the entire raw message value. No other operations
    are performed on the data if this type of handler is used. Optional - see
    the "Custom Handlers" section for more.

`ignore` - Setting this to `true` on a signal will silence output of that
    signal. The translator will not monitor the signal nor store any of its
    values. This is useful if you are using a custom handler for an entire
    message, want to silence the normal output of the signals it handles, and
    you don't need the translator to keep track of the values of any of the
    signals separately. If you need to use the previously stored values of any
    of ths signals, you can use the `ignoreHandler` as a value handler for the
    signal.

`states` - For state values, this is a mapping between the desired descriptive
    enum states (e.g. `off`) and a list of the corresponding raw state values
    from the CAN bus (usually an integer). The raw values are specified as a
    list to accommodate multiple raw states being coalesced into a single final
    state (e.g. key off and key removed both mapping to just "off").

`send_frequency` - Some CAN signals are sent at a very high frequency, likely
    more often than will ever be useful to an application. This attribute
    defaults to `1` meaning that `1/1` (i.e. 100%) of the values for this signal
    will be processed and sent over USB. Increasing the value will reduce the
    number of messages that are sent - a value of `10` means that only `1/10`
    messages (i.e. every 10th message) is processed. You don't want to combine
    this attribute with `send_same` or else you risk missing a status change
    message if wasn't one of the messages the translator decided to let through.

`send_same` - By default, all signals are process and sent over USB every time
    they are received on the CAN bus. By setting this to `false`, you can force
    a signal to be sent only if the value has actually changed. This works best
    with boolean and state based signals.

`writable` - The only signals read through the `OUT` channel of the USB device
    (i.e. from the host device back to the CAN translator) that are actually
    encoded and written back to the CAN bus are those marked with this flag
    true. By default, the value will be interpreted as a floating point number.

`write_handler` - If the signal is writable and is not a plain floating point
    number (i.e. it is a boolean or state value), you can specify a custom
    function here to encode the value for a CAN messages. This is only necessary
    for boolean types at the moment - if your signal has states defined, we
    assume you need to encode a string state value back to its original
    numerical value.

Optionally, you can specify completely custom handler functions to process
incoming OpenXC messages from the USB host. In the `commands` section of the
JSON object, you can specify the generic name of the OpenXC command and an
associated function that matches the `WriteHandler` function prototype (from
`canutil.h`). Any message received from the USB host with that name will be
passed to your handler - this is useful for situations where there isn't a 1 to
1 mapping between OpenXC command and CAN signal, e.g. if the left and right turn
signal are split into two signals instead of the 1 state-based signal used by
OpenXC. You can use the `sendCanSignal` function in `canwrite.h` to do the
actual data sending on the CAN bus.

## Custom Handlers

The default handler for each signal is a simple passthrough, translating the
signal's ID to an abstracted name (e.g. `SteeringWheelAngle`) and its value from
engineering units to something more usable. Some signals require additional
processing that you may wish to do within the translator and not on the host
device. Other signals may need to be combined to make a composite signal that's
more meaningful to developers.

An good example is steering wheel angle. For an app developer to get a value
that ranges from e.g. -350 to +350, we need to combine two different signals -
the angle and the sign. If you want to make this combination happen inside the
translator, you can use a custom handler.

You may also need a custom handler to return a value of a type other than float.
A handler is provided for dealing with boolean values, the `booleanHandler` - if
you specify that as your signal's `value_handler` the resulting JSON will
contain `true` for 1.0 and `false` for 0.0. If you want to translate integer
state values to string names (for parsing as an enum, for example) you will need
to write a value handler that returns a `char*`.

There are two levels of custom handlers:

* Message handlers - use these for custom processing of the entire CAN message.
* Value handlers - use these for making non-standard transformations to a signal
  value

For this example, we want to modify the value of `SteeringWheelAngle` by setting
the sign positive or negative based on the value of the other signal
(`StrAnglSign`). Every time a CAN signal is received, the new value is stored in
memory. Our custom handler `handleSteeringWheelAngle` will use that to adjust
the raw steering wheel angle value.

    float handleSteeringWheelAngle(CanSignal* signal, CanSignal* signals,
            int signalCount, float value, bool* send) {
        if(signal->lastValue == 0) {
            // left turn
            value *= -1;
        }
        return value;
    }

The valid return types for value handlers are `bool`, `float` and `char*` - the
function prototype must match one of:

    char* customHandler(CanSignal* signal, CanSignal* signals, int signalCount,
            float value, bool* send);

    float customHandler(CanSignal* signal, CanSignal* signals, int signalCount,
            float value, bool* send);

    bool customhandler(cansignal* signal, cansignal* signals, int signalCount,
            float value, bool* send);

where `signal` is a pointer to the `CanSignal` this is handling, `signals` is a
an array of all signals, `value` is the raw value from CAN and `send` is a flag
to indicate if this should be sent over USB.

The `bool* send` parameter is a pointer to a `bool` you can flip to `false` if
this signal value need not be sent over USB. This can be useful if you don't
want to keep notifying the same status over and over again, but only in the
event of a change in value (you can use the `lastValue` field on the CanSignal
object to determine if this is true).

A known issue with this method is that there is no guarantee that the last value
of another signal arrived in the message or before/after the value you're
current modifying. For steering wheel angle, that's probably OK - for other
signals, not so much.

If you need greater precision, you can provide a custom handler for the entire
message to guarantee they arrived together. You can generate 0, 1 or many
translated messages from one call to your handler function.

    void handleSteeringWheelMessage(int messageId, uint8_t* data,
            CanSignal* signals, int signalCount, USBDevice* usbDevice) {
        float steeringWheelAngle = decodeCanSignal(&signals[1], data);
        float steeringWheelSign = decodeCanSignal(&signals[2], data);

        float finalValue = steeringWheelAngle;
        if(steeringWheelSign == 0) {
            // left turn
            finalValue *= -1;
        }

        char* message = generateJson(signals[1], finalValue);
        sendMessage(usbDevice, (uint8_t*) message, strlen(message));
    }

Using a custom message handler will not stop individual messages for each signal
from being output. To silence them but still store their values in
`signal->lastvalue` as they come in, specify the special `ignoreHandler` as the
`value_handler` for signals don't want to double send. The reason we don't do
this automatically is that not all signals in a message are always handled by
the same message handler.

## Sketch Generation

With this JSON list in hand, you next need to generate the C source code that
defines a `decodeCanMessage` function that can process the signals you've
defined. The generated source is a conversion of your JSON to an array of
C-structs, ready to be read by the translator at runtime.

To generate code, we've provided the `generate_code.py` script. Use it like so:

    $ generate_code.py signals.json > src/signals.cpp

then rebuild your sketch - everything should build properly now.

Don't add anything else to this file - it's derivative of the master JSON, and
should be able to be wiped and recreated at any time.

### Vector DBC files

If you use Canoe to store your "gold standard" CAN signal definitions, you may
be able to use the included `xml_to_json.py` script to make your JSON for you.
First, export the Canoe .dbc file as XML - you can do this with Vector CANdb++.
Run the conversion script like this:

    $ xml_to_json.py signals.xml signal_mapping.txt build/signals.json

The `signal_mapping.txt` file is a simple mapping of the signal names that we
are looking for in the XML and a unique numerical ID to associate it
with.

## Output Specification

See the [output
format](http://openxcplatform.com/vehicle-interface/output-format.html) section
of the [OpenXC][] website for details on the output format.

## Serial Output

You can optionally receive the output data over a serial connection in
addition to USB. The messages are automatically sent over a UART connection on
pins 18 and 19 of the chipKIT Max32 at a baud rate of 115200 when not being sent
over USB. To be absolutely clear, OpenXC messages are only sent over serial if
an active USB connection is **not** already receiving the messages.

In the same way that you can send OpenXC writes over USB using the OUT direction
of the USB endpoint, you can send identically formatted messages in the opposite
direction on the serial device - from the host to the CAN translator. They'll be
processed in exactly the same way. These write messages are accepted via serial
even if USB is connected.
=======
## Pre-built Binary

If you've downloaded a pre-built binary for a specific vehicle, see the [firmware
section](http://openxcplatform.com/vehicle-interface/firmware.html) of the
[OpenXC website](http://openxcplatform.com) for instructions on how to flash
your CAN translator. Most users do not need to set up the full development
described in these docs.

## Testing

The [OpenXC Python library](https://github.com/openxc/openxc-python), in
particular the `openxc-dashboard` tool, is useful for testing the CAN translator with a regular
computer, to verify the data received from a vehicle before introducing an
Android device. Documentation for this tool (and the list of required
dependencies) is available on the OpenXC [vehicle interface
testing](http://openxcplatform.com/vehicle-interface/testing.html) page.

## Traces

You can record a trace of JSON messages from the CAN reader for use in testing.
First, install the [OpenXC Python library](python-lib). Then attach the CAN
translator to your computer via USB and use the `openxc-dump` program to print
all raw JSON messages to stdout. Redirect this to a file, and you've got your
trace. This can be used directly by the openxc-android library, for example.

    $ openxc-dump > vehicle-data.trace

[python-lib]: https://github.com/openxc/openxc-python

## Output Specification

See the [output
format](http://openxcplatform.com/vehicle-interface/output-format.html) section
of the [OpenXC][] website for details on the output format.

## Contributing

Please see our [Contibution Guide](https://github.com/openxc/cantranslator/blob/master/CONTRIBUTING.mkd)
and additional [developer documentation](dev-docs).

## License

This source code is available under the BSD license.

[dev-docs]: https://github.com/openxc/cantranslator/blob/master/README_developers.mkd

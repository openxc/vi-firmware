
## Installation

Building the source for the CAN translator for the chipKIT microcontroller
requires [MPIDE][] (the development environment and compiler toolchain for
chipKIT provided by Digilent) and a few library dependencies:

* Microchip USB device library (download DSD-0000318 from
    the bottom of the [Network Shield page][])
* Microchip CAN library (included in the same DSD-0000318 package as the USB
  device library)
* [cJSON](http://sourceforge.net/projects/cjson/)

Installing MPIDE can be a bit quirky on some platforms, so if you're having
trouble take a look at the [installation guide for
MPIDE](http://chipkit.org/wiki/index.php?title=MPIDE_Installation).

Download these libraries and extract them to your MPIDE sketchbook directory in
a subdirectory named `libraries`. It should look like this:

    - /Users/me/sketchbook/
    ---- libraries/
    -------- chipKITUSBDevice/
             chipKitCAN/
             cJSON/
            ... other libraries

If you're using Mac OS X or Windows, make sure to install the FTDI driver that
comes with the MPIDE download. The chipKIT uses a different FTDI chip, so even
if you've used the Arduino before, you still need to install this driver.

[MPIDE]: https://github.com/chipKIT32/chipKIT32-MAX/downloads
[Max32 page]: http://digilentinc.com/Products/Detail.cfm?NavPath=2,719,895&Prod=CHIPKIT-MAX32
[Network Shield page]: http://digilentinc.com/Products/Detail.cfm?NavPath=2,719,943&Prod=CHIPKIT-NETWORK-SHIELD

### GUI Building

Although we just installed MPIDE, building via the GUI is **not supported**.

### Command Line Building

We use GNU Make to compile and upload code to the device. You still need to
download and extract the MPIDE someplace, as it contains the PIC32 compilation
toolchain.

This requires that you clone the [arduino.mk][] repository someone on your
computer. This contains Makefile definitions common to Arduino and chipKIT
platforms.

    $ git clone https://github.com/peplin/arduino.mk.git

You also need to set a few environment variables (e.g. in your `.bashrc`) for
this method (make sure to change these defaults if your system is different!):

    # Path to the extracted MPIDE folder (this is correct for OS X)
    export MPIDE_DIR=/Applications/Mpide.app/Contents/Resources/Java

    # Path to the `arduino.mk` repository you just cloned
    export ARDUINO_MAKEFILE_HOME=$HOME/projects/arduino.mk

Optionally, set the `ARDUINO_PORT` variable if the serial emulator doesn't
show up as `/dev/ttyUSB*` (in Linux) or `/dev/tty.usbserial*` (in Mac OS X).

Remember that if you use `export`, the environment variables are only set in the
terminal that you run the commands. If you want them active in all terminals
(and you probably do), you need to add these `export ...` lines to the file
`~/.bashrc` and restart your terminals.

Once this is set up, `cd` into the `cantranslator` subdirectory, build and
upload to the device:

    $ make clean
    $ make
    $ make upload

[arduino.mk]: https://github.com/peplin/arduino.mk

## Compiling and Uploading

Once the libraries are installed and you run `make`, you'll notice that it won't
compile - you'll get a bunch of errors that look like this:

```
build-cli/canutil_chipkit.o: In function `initializeCan(CanBus*)':
canutil_chipkit.cpp:(.text._Z13initializeCanP6CanBus+0xb8): undefined reference to `initializeFilterMasks(unsigned long long, int*)'
canutil_chipkit.cpp:(.text._Z13initializeCanP6CanBus+0xcc): undefined reference to `initializeFilters(unsigned long long, int*)'
build-cli/cantranslator.o: In function `receiveWriteRequest(char*)':
cantranslator.cpp:(.text._Z19receiveWriteRequestPc+0x40): undefined reference to `getSignals()'
cantranslator.cpp:(.text._Z19receiveWriteRequestPc+0x48): undefined reference to `getSignalCount()'
cantranslator.cpp:(.text._Z19receiveWriteRequestPc+0x7c): undefined reference to `getCommands()'
cantranslator.cpp:(.text._Z19receiveWriteRequestPc+0x84): undefined reference to `getCommandCount()'
cantranslator.cpp:(.text._Z19receiveWriteRequestPc+0xa4): undefined reference to `getSignals()'
cantranslator.cpp:(.text._Z19receiveWriteRequestPc+0xac): undefined reference to `getSignalCount()'
cantranslator.cpp:(.text._Z19receiveWriteRequestPc+0x118): undefined reference to `getSignals()'
cantranslator.cpp:(.text._Z19receiveWriteRequestPc+0x120): undefined reference to `getSignalCount()'
build-cli/cantranslator.o: In function `initializeAllCan()':
cantranslator.cpp:(.text._Z16initializeAllCanv+0x1c): undefined reference to `getCanBuses()'
cantranslator.cpp:(.text._Z16initializeAllCanv+0x30): undefined reference to `getCanBusCount()'
build-cli/cantranslator.o: In function `_ZL17customUSBCallback9USB_EVENTPvj.clone.0':
cantranslator.cpp:(.text._ZL17customUSBCallback9USB_EVENTPvj.clone.0+0x70): undefined reference to `getMessageSet()'
cantranslator.cpp:(.text._ZL17customUSBCallback9USB_EVENTPvj.clone.0+0x98): undefined reference to `getMessageSet()'
build-cli/cantranslator.o: In function `receiveCan(CanBus*)':
cantranslator.cpp:(.text._Z10receiveCanP6CanBus+0x40): undefined reference to `decodeCanMessage(int, unsigned char*)'
build-cli/cantranslator.o: In function `loop':
cantranslator.cpp:(.text.loop+0x1c): undefined reference to `getCanBuses()'
cantranslator.cpp:(.text.loop+0x30): undefined reference to `getCanBusCount()'
collect2: ld returned 1 exit status
make[1]: *** [build-cli/cantranslator.elf] Error 1
make[1]: Leaving directory `/home/peplin/dev/ford/cantranslator/cantranslator'
make: *** [all] Error 2
```

The open source repository is missing the definition of a `decodeCanMessage`
function (and a few others functions declared in `signals.h`). These are the
parts you must implement yourself if have details about your vehicle's message
formats, or by following the input specification designed here, have
auto-generated.

You have three options: implementing these functions manually for your specific
vehicle, using the code auto-generation scripts or using a pre-built binary.

### Manual

You must implement the functions defined in the `signals.h` header file. The
documentation of those functions describes the expected effect of each.
Implement these in a file called `signals.cpp` and the code should now compile.

You must know the CAN message formats of the vehicle you want to use with the
CAN translator, as you cannot implement these functions without that knowledge.

### Auto-generation

The code auto-generation script accepts a [JSON input file](input-specs) that
defines the CAN messages and signals of interest and rewrites it as C data
structures, ready to be downloaded to the device. Check the "Input
Specification" section for the details of the input format. You must know the
CAN message formats of the vehicle you want to use with the CAN translator, as
you cannot create these input files without that knowledge.

Once you have one or more input JSON files, run the `generate_source.py` script
to create a file that defines `decodeCanMessage`:

    ./generate_code.py --json signals.json > signals.cpp

Drop the new `signals.cpp` file in the `cantranslator` sketch folder, and it
should now compile. Don't add anything else to this file - it's derivative of
the master JSON, and should be able to be wiped and recreated at any time.

If you have multiple CAN buses and want to define their signals and messages in
separate files, just pass multiple JSON files:

    ./generate_code.py --json highspeed.json --json mediumspeed.json > signals.cpp

Note that the JSON files are parsed and merged, so if you want to define custom
handlers and states separately from the signal definition itself, you can store
them in separate files and they will be merged on import.

## Test Suite

The non-chipKIT code in this repository includes a small test suite that uses
the [check][] library. After installing that library, run the test suite like
so:

    cantranslator/ $ make test

The [check][] library can be installed in Ubuntu Linux quite easily:

    $ sudo apt-get install check

and in Mac OS X, it's available through [homebrew][]:

    $ brew install check

[check]: http://check.sourceforge.net
[homebrew]: http://mxcl.github.com/homebrew/

## Emulator

The repository includes a rudimentary CAN bus emulator. Use the `EMULATOR` flag
to build this:

    $ make clean
    $ EMULATOR=1 make -j4

The emulator generates fakes values for many OpenXC signals and sends them over
USB as if it were plugged into a live CAN bus.

## USB Device Driver

For details on the USB device, particularly useful if you are trying to connect
to it from a new programming language or environment, see the [USB
readme](https://github.com/openxc/cantranslator/blob/master/README_usb.mkd).

## Serial Output

You can optionally receive the output data over a serial connection in
addition to USB. The messages are automatically sent over a UART connection on
pins 18 and 19 of the chipKIT Max32 at a baud rate of 115200 when not being sent
over USB. To be absolutely clear, OpenXC messages are only sent over serial if
an active USB connection is **not** already receiving the messages.

In the same way that you can send OpenXC writes over USB using the OUT direction
of the USB endpoint, you can send identically formatted messages in the opposite
direction on the serial device - from the host to the CAN translator. They'll be
processed in exactly the same way. These write messages are accepted via serial
even if USB is connected.

[input-specs]: https://github.com/openxc/cantranslator/blob/master/README_mappings.mkd
